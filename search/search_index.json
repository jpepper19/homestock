{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83c\udfe1 homestock","text":"<p>homestock is a Python package designed to simplify access to American Community Survey (ACS) data from the U.S. Census Bureau. It enables users to fetch detailed demographic, housing, and economic data, and seamlessly convert the results into <code>pandas</code> DataFrames or CSV files for further analysis.</p> <p>Whether you're exploring patterns at the state level or diving deep into neighborhoods using census tracts and block groups, homestock provides a flexible, scriptable workflow for researchers, students, journalists, and developers.</p>"},{"location":"#what-is-the-acs","title":"\ud83d\udcca What is the ACS?","text":"<p>The American Community Survey (ACS) is an ongoing survey conducted by the U.S. Census Bureau that collects vital information on income, education, housing, employment, and more.</p> <p>There are two primary types of ACS data products:</p>"},{"location":"#1-year-estimates","title":"\ud83d\udd39 1-Year Estimates","text":"<ul> <li>Based on data collected over 12 months</li> <li>Available for areas with populations of 65,000+</li> <li>Best for analyzing current trends in large cities or regions</li> <li>Less stable for small populations due to smaller sample size</li> </ul>"},{"location":"#5-year-estimates","title":"\ud83d\udd38 5-Year Estimates","text":"<ul> <li>Based on data collected over 60 months (5 years)</li> <li>Available for all geographic areas, down to block groups</li> <li>Best for granular spatial analysis or long-term planning</li> <li>More reliable for small population areas</li> </ul>"},{"location":"#supported-geographic-levels","title":"\ud83d\uddfa\ufe0f Supported Geographic Levels","text":"Geographic Level Description Available In Nation Entire United States 1-Year, 5-Year State Individual U.S. states 1-Year, 5-Year County Counties within states 1-Year, 5-Year County Subdivision Minor civil divisions (e.g., townships) 5-Year only Place Incorporated places (cities, towns) 1-Year, 5-Year ZIP Code Tabulation Area (ZCTA) Approximated ZIP Code boundaries 5-Year only Metropolitan/Micropolitan Area Census-defined metro or micro areas 1-Year, 5-Year Census Tract Small subdivisions of counties (~4,000 residents) 5-Year only Block Group Subdivisions of tracts (~600\u20133,000 residents) 5-Year only Block The smallest geography (~40\u2013100 people) 5-Year only"},{"location":"#what-can-you-do-with-homestock","title":"\u2699\ufe0f What Can You Do with homestock?","text":"<ul> <li>\ud83e\udde9 Pull specific ACS tables by table ID (e.g., <code>B19013</code> for median household income)</li> <li>\ud83d\udcc1 Convert results to <code>pandas</code> DataFrames or export them as <code>.csv</code></li> <li>\ud83c\udf10 Query different geographic levels, from national down to individual blocks</li> <li>\ud83d\udd0d Explore metadata dynamically using Census variable labels</li> <li>\ud83d\uddfa\ufe0f Use results in mapping tools like <code>folium</code>, <code>geopandas</code>, or <code>leafmap</code></li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#homestock.common.hello_world","title":"<code>hello_world()</code>","text":"<p>Prints \"Hello World!\" to the console.</p> Source code in <code>homestock/common.py</code> <pre><code>def hello_world():\n    \"\"\"Prints \"Hello World!\" to the console.\"\"\"\n    print(\"Hello World!\")\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/jpepper19/homestock/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>homestock could always use more documentation, whether as part of the official homestock docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/jpepper19/homestock/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up homestock for local development.</p> <ol> <li> <p>Fork the homestock repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/homestock.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv homestock\n$ cd homestock/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 homestock tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/jpepper19/homestock/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"folium_map/","title":"folium_map.py API Documentation","text":"<p>Folium Module</p>"},{"location":"folium_map/#homestock.folium_map.Map","title":"<code> Map            (Map)         </code>","text":"<p>class that extends folium.Map. This class is used to create a map with additional functionalities.</p> Source code in <code>homestock/folium_map.py</code> <pre><code>class Map(folium.Map):\n    \"\"\"\n    class that extends folium.Map.\n    This class is used to create a map with additional functionalities.\n    \"\"\"\n\n    def __init__(self, center=(0, 0), zoom=2, **kwargs):\n        super().__init__(location=center, zoom_start=zoom, **kwargs)\n\n    def add_basemap(self, name: str, **kwargs):\n        \"\"\"\n        Add a basemap to the map using Esri maps.\n        Args:\n            name (str): Name of the basemap.\n            **kwargs: Additional arguments to pass to the folium.TileLayer.\n        \"\"\"\n        basemaps = {\n            \"Road\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}\",\n            \"Satellite\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\",\n            \"Topo\": \"https://server.arcgisonline.com/ArcGIS/rest/services/Topographic/MapServer/tile/{z}/{y}/{x}\",\n            \"Terrain\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Terrain_Base/MapServer/tile/{z}/{y}/{x}\",\n        }\n        if name in basemaps:\n            folium.TileLayer(\n                tiles=basemaps[name],\n                attr='&amp;copy; &lt;a href=\"http://www.esri.com/\"&gt;Esri&lt;/a&gt;',\n                **kwargs,\n            ).add_to(self)\n        else:\n            raise ValueError(f\"Basemap '{name}' not found.\")\n\n    def add_geojson(self, data, name=\"GeoJSON Layer\", **kwargs):\n        \"\"\"Adds a GeoJSON layer to the map.\n\n        Args:\n            data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n            name (str): Name of the layer to display in the LayerControl. Defaults to \"GeoJSON Layer\".\n            **kwargs: Additional keyword arguments for the folium.GeoJson layer.\n        \"\"\"\n        import geopandas as gpd\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            geojson = gdf.__geo_interface__\n        elif isinstance(data, dict):\n            geojson = data\n\n        geojson_layer = folium.GeoJson(data=geojson, name=name, **kwargs)\n        geojson_layer.add_to(self)\n\n    def add_shp(self, data, **kwargs):\n        \"\"\"Adds a shapefile to the map.\n\n        Args:\n            data (str): The file path to the shapefile.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        import geopandas as gpd\n\n        gdf = gpd.read_file(data)\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_gdf(self, gdf, name=\"GDF Layer\", **kwargs):\n        \"\"\"Adds a GeoDataFrame to the map.\n\n        Args:\n            gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, name, **kwargs)\n\n    def add_vector(self, data, name=\"Vector Layer\", **kwargs):\n        \"\"\"Adds vector data to the map.\n\n        Args:\n            data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n            name (str): Name of the layer to display in the LayerControl. Defaults to \"Vector Layer\".\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            self.add_gdf(gdf, name=name, **kwargs)\n        elif isinstance(data, gpd.GeoDataFrame):\n            self.add_gdf(data, name=name, **kwargs)\n        elif isinstance(data, dict):\n            self.add_geojson(data, name=name, **kwargs)\n        else:\n            raise ValueError(\"Invalid data type\")\n\n    def add_layer_control(self):\n        \"\"\"Adds a layer control widget to the map.\"\"\"\n        folium.LayerControl().add_to(self)\n\n    def add_raster(self, data: str, layer_name: str, **kwargs):\n        \"\"\"\n        Add a raster layer to the map.\n        Args:\n            data (str): Path to the raster file.\n            layer_name (str): Name of the layer.\n            **kwargs: Additional arguments to pass to the folium.ImageOverlay.\n        \"\"\"\n        folium.ImageOverlay(data, name=layer_name, **kwargs).add_to(self)\n\n    def add_split_map(self, left=\"openstreetmap\", right=\"cartodbpositron\", **kwargs):\n\n        layer_right = folium.TileLayer(left, **kwargs)\n        layer_left = folium.TileLayer(right, **kwargs)\n\n        sbs = folium.plugins.SideBySideLayers(\n            layer_left=layer_left, layer_right=layer_right\n        )\n\n        # Allow for raster TIFs to be added to left or right\n        if isinstance(left, str) and left.endswith(\".tif\"):\n            layer_left = folium.ImageOverlay(left, **kwargs)\n        if isinstance(right, str) and right.endswith(\".tif\"):\n            layer_right = folium.ImageOverlay(right, **kwargs)\n\n        layer_left.add_to(self)\n        layer_right.add_to(self)\n        sbs.add_to(self)\n\n    def show_map(self):\n        \"\"\"\n        Displays the folium map in the Jupyter notebook or Python script.\n        \"\"\"\n        return self.map\n</code></pre>"},{"location":"folium_map/#homestock.folium_map.Map.add_basemap","title":"<code>add_basemap(self, name, **kwargs)</code>","text":"<p>Add a basemap to the map using Esri maps.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the basemap.</p> required <code>**kwargs</code> <p>Additional arguments to pass to the folium.TileLayer.</p> <code>{}</code> Source code in <code>homestock/folium_map.py</code> <pre><code>def add_basemap(self, name: str, **kwargs):\n    \"\"\"\n    Add a basemap to the map using Esri maps.\n    Args:\n        name (str): Name of the basemap.\n        **kwargs: Additional arguments to pass to the folium.TileLayer.\n    \"\"\"\n    basemaps = {\n        \"Road\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}\",\n        \"Satellite\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\",\n        \"Topo\": \"https://server.arcgisonline.com/ArcGIS/rest/services/Topographic/MapServer/tile/{z}/{y}/{x}\",\n        \"Terrain\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Terrain_Base/MapServer/tile/{z}/{y}/{x}\",\n    }\n    if name in basemaps:\n        folium.TileLayer(\n            tiles=basemaps[name],\n            attr='&amp;copy; &lt;a href=\"http://www.esri.com/\"&gt;Esri&lt;/a&gt;',\n            **kwargs,\n        ).add_to(self)\n    else:\n        raise ValueError(f\"Basemap '{name}' not found.\")\n</code></pre>"},{"location":"folium_map/#homestock.folium_map.Map.add_gdf","title":"<code>add_gdf(self, gdf, name='GDF Layer', **kwargs)</code>","text":"<p>Adds a GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>geopandas.GeoDataFrame</code> <p>The GeoDataFrame to add.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>homestock/folium_map.py</code> <pre><code>def add_gdf(self, gdf, name=\"GDF Layer\", **kwargs):\n    \"\"\"Adds a GeoDataFrame to the map.\n\n    Args:\n        gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, name, **kwargs)\n</code></pre>"},{"location":"folium_map/#homestock.folium_map.Map.add_geojson","title":"<code>add_geojson(self, data, name='GeoJSON Layer', **kwargs)</code>","text":"<p>Adds a GeoJSON layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str or dict</code> <p>The GeoJSON data. Can be a file path (str) or a dictionary.</p> required <code>name</code> <code>str</code> <p>Name of the layer to display in the LayerControl. Defaults to \"GeoJSON Layer\".</p> <code>'GeoJSON Layer'</code> <code>**kwargs</code> <p>Additional keyword arguments for the folium.GeoJson layer.</p> <code>{}</code> Source code in <code>homestock/folium_map.py</code> <pre><code>def add_geojson(self, data, name=\"GeoJSON Layer\", **kwargs):\n    \"\"\"Adds a GeoJSON layer to the map.\n\n    Args:\n        data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n        name (str): Name of the layer to display in the LayerControl. Defaults to \"GeoJSON Layer\".\n        **kwargs: Additional keyword arguments for the folium.GeoJson layer.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        geojson = gdf.__geo_interface__\n    elif isinstance(data, dict):\n        geojson = data\n\n    geojson_layer = folium.GeoJson(data=geojson, name=name, **kwargs)\n    geojson_layer.add_to(self)\n</code></pre>"},{"location":"folium_map/#homestock.folium_map.Map.add_layer_control","title":"<code>add_layer_control(self)</code>","text":"<p>Adds a layer control widget to the map.</p> Source code in <code>homestock/folium_map.py</code> <pre><code>def add_layer_control(self):\n    \"\"\"Adds a layer control widget to the map.\"\"\"\n    folium.LayerControl().add_to(self)\n</code></pre>"},{"location":"folium_map/#homestock.folium_map.Map.add_raster","title":"<code>add_raster(self, data, layer_name, **kwargs)</code>","text":"<p>Add a raster layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>Path to the raster file.</p> required <code>layer_name</code> <code>str</code> <p>Name of the layer.</p> required <code>**kwargs</code> <p>Additional arguments to pass to the folium.ImageOverlay.</p> <code>{}</code> Source code in <code>homestock/folium_map.py</code> <pre><code>def add_raster(self, data: str, layer_name: str, **kwargs):\n    \"\"\"\n    Add a raster layer to the map.\n    Args:\n        data (str): Path to the raster file.\n        layer_name (str): Name of the layer.\n        **kwargs: Additional arguments to pass to the folium.ImageOverlay.\n    \"\"\"\n    folium.ImageOverlay(data, name=layer_name, **kwargs).add_to(self)\n</code></pre>"},{"location":"folium_map/#homestock.folium_map.Map.add_shp","title":"<code>add_shp(self, data, **kwargs)</code>","text":"<p>Adds a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The file path to the shapefile.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>homestock/folium_map.py</code> <pre><code>def add_shp(self, data, **kwargs):\n    \"\"\"Adds a shapefile to the map.\n\n    Args:\n        data (str): The file path to the shapefile.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    import geopandas as gpd\n\n    gdf = gpd.read_file(data)\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"folium_map/#homestock.folium_map.Map.add_vector","title":"<code>add_vector(self, data, name='Vector Layer', **kwargs)</code>","text":"<p>Adds vector data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str, geopandas.GeoDataFrame, or dict</code> <p>The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.</p> required <code>name</code> <code>str</code> <p>Name of the layer to display in the LayerControl. Defaults to \"Vector Layer\".</p> <code>'Vector Layer'</code> <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>homestock/folium_map.py</code> <pre><code>def add_vector(self, data, name=\"Vector Layer\", **kwargs):\n    \"\"\"Adds vector data to the map.\n\n    Args:\n        data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n        name (str): Name of the layer to display in the LayerControl. Defaults to \"Vector Layer\".\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        self.add_gdf(gdf, name=name, **kwargs)\n    elif isinstance(data, gpd.GeoDataFrame):\n        self.add_gdf(data, name=name, **kwargs)\n    elif isinstance(data, dict):\n        self.add_geojson(data, name=name, **kwargs)\n    else:\n        raise ValueError(\"Invalid data type\")\n</code></pre>"},{"location":"folium_map/#homestock.folium_map.Map.show_map","title":"<code>show_map(self)</code>","text":"<p>Displays the folium map in the Jupyter notebook or Python script.</p> Source code in <code>homestock/folium_map.py</code> <pre><code>def show_map(self):\n    \"\"\"\n    Displays the folium map in the Jupyter notebook or Python script.\n    \"\"\"\n    return self.map\n</code></pre>"},{"location":"homestock/","title":"homestock.py API Documentation","text":"<p>Main Homestock Module.</p>"},{"location":"homestock/#homestock.homestock.CensusData","title":"<code> CensusData        </code>","text":"Source code in <code>homestock/homestock.py</code> <pre><code>class CensusData:\n    def __init__(self, table_file=\"acs_tables.csv\"):\n        \"\"\"Initialize CensusData with optional custom table file.\n\n        Args:\n            table_file (str): Filename of ACS tables CSV. Defaults to \"acs_tables.csv\".\n        \"\"\"\n        # Get absolute path to the CSV file\n        self.table_path = Path(__file__).parent / table_file\n\n        # Verify file exists at initialization\n        if not self.table_path.exists():\n            raise FileNotFoundError(f\"ACS tables file not found at: {self.table_path}\")\n\n    def search_census_tables(self, keyword=None):\n        \"\"\"Search the Census tables based on a keyword.\n\n        Args:\n            keyword (str, optional): Keyword to search in table titles. If None, prompts user.\n\n        Returns:\n            pd.DataFrame: Contains columns 'Table ID', 'Table Title', and 'Year'.\n        \"\"\"\n        # Get keyword input if not provided\n        if keyword is None:\n            keyword = input(\"Enter a keyword to search Census tables: \").lower()\n\n        matching_tables = []\n\n        # Read data using absolute path\n        with open(self.table_path, mode=\"r\", encoding=\"utf-8\") as file:\n            reader = csv.DictReader(file)\n            for row in reader:\n                if keyword in row[\"Table Title\"].lower():\n                    matching_tables.append({\n                        \"Table ID\": row[\"Table ID\"],\n                        \"Table Title\": row[\"Table Title\"], \n                        \"Year\": row[\"Year\"]\n                    })\n\n        # Convert to DataFrame\n        result = pd.DataFrame(matching_tables)\n\n        # Print formatted output\n        if not result.empty:\n            print(f\"\\nMatching Census Tables for '{keyword}':\\n\")\n            print(tabulate(result, headers=\"keys\", tablefmt=\"grid\", showindex=False))\n        else:\n            print(f\"\\nNo matching tables found for '{keyword}'\")\n\n        return result\n\n    def get_acs_data():\n        \"\"\"Fetch ACS data at various geographic levels with interactive prompts.\n\n        Prompts user for inputs, fetches ACS data at various geographic levels, \n        supports multiple years, and offers CSV export option.\n\n        Returns:\n            pd.DataFrame: If one year requested\n            dict: Dictionary of {year: pd.DataFrame} if multiple years requested\n\n        Note: This interactive function prompts for:\n            - API Key (required)\n            - Table ID (e.g., \"B19001\")\n            - Year(s) (comma-separated)\n            - Survey type (\"1\" or \"5\")\n            - Geography level\n            - State/county details (when applicable)\n            - CSV export options\n        \"\"\"\n        print(\"Welcome to the ACS Data Fetcher!\")\n\n        # Get API key\n        api_key = input(\"Enter your Census API key: \").strip()\n        if not api_key:\n            raise ValueError(\"API key is required.\")\n\n        # Get table ID\n        table = input(\"Enter the ACS table ID (e.g., B19001): \").strip().upper()\n        if not table:\n            raise ValueError(\"Table ID is required.\")\n\n        # Get year(s) - support for multiple years\n        year_input = input(\"Enter ACS year(s) (comma-separated for multiple, e.g., 2018,2019,2020): \").strip()\n        if not year_input:\n            years = [2020]\n        else:\n            try:\n                years = [int(y.strip()) for y in year_input.split(\",\")]\n            except ValueError:\n                raise ValueError(\"Years must be comma-separated integers (e.g., '2018,2019,2020')\")\n\n        # Get survey type\n        survey_type = input(\"Enter survey type ('5' for ACS 5-year, '1' for ACS 1-year): \").strip()\n        if survey_type not in {'1', '5'}:\n            raise ValueError(\"Survey type must be '1' or '5'.\")\n        acs_survey = f\"acs{survey_type}\"\n\n        # Get geography level\n        valid_geographies = {\n            \"acs5\": [\n                \"Nation\", \"State\", \"County\", \"County Subdivision\", \"Place\", \"ZIP Code Tabulation Area\",\n                \"Metropolitan/Micropolitan Statistical Area\", \"Census Tract\", \"Block\", \"Block Group\"\n            ],\n            \"acs1\": [\n                \"Nation\", \"State\", \"County\", \"Metropolitan/Micropolitan Statistical Area\", \"Place\"\n            ]\n        }\n\n        print(f\"\\nAvailable geographic levels for {acs_survey}:\")\n        for idx, geo in enumerate(valid_geographies[acs_survey], 1):\n            print(f\"{idx}. {geo}\")\n\n        geo_selection = input(\"Enter the number corresponding to your desired geographic level: \").strip()\n        if not geo_selection.isdigit() or int(geo_selection) not in range(1, len(valid_geographies[acs_survey]) + 1):\n            raise ValueError(\"Invalid selection. Please enter a number from the list.\")\n\n        geography = valid_geographies[acs_survey][int(geo_selection) - 1]\n        print(f\"You selected: {geography}\")\n\n        # Get state input if needed\n        state_fips = None\n        state_name = None\n        if geography in [\"State\", \"County\", \"County Subdivision\", \"Place\", \"ZIP Code Tabulation Area\", \n                        \"Census Tract\", \"Block\", \"Block Group\"]:\n            state_name = input(\"Enter the full state name (e.g., Tennessee): \").strip()\n            state_obj = us.states.lookup(state_name)\n            if not state_obj:\n                raise ValueError(f\"Invalid state name: {state_name}\")\n            state_fips = state_obj.fips\n\n        # Get additional geography-specific inputs\n        geo_params = {}\n        if geography == \"County\":\n            county_name = input(\"Enter the county name (e.g., Knox) or * for all counties: \").strip()\n            geo_params['county_name'] = county_name\n        elif geography == \"Place\":\n            place_id = input(\"Enter the Place ID or * for all places in the state: \").strip()\n            geo_params['place_id'] = place_id\n        elif geography == \"Metropolitan/Micropolitan Statistical Area\":\n            metro_id = input(\"Enter the Metro/Micro area ID: \").strip()\n            geo_params['metro_id'] = metro_id\n        elif geography == \"ZIP Code Tabulation Area\":\n            zip_id = input(\"Enter the ZIP Code Tabulation Area ID or * for all: \").strip()\n            geo_params['zip_id'] = zip_id\n        elif geography in [\"Census Tract\", \"Block Group\", \"Block\"]:\n            county_name = input(\"Enter the county name (e.g., Knox) or * for all counties: \").strip()\n            geo_params['county_name'] = county_name\n            if geography == \"Census Tract\":\n                tract_id = input(\"Enter the Census Tract number or * for all tracts in this county: \").strip()\n                geo_params['tract_id'] = tract_id\n            elif geography == \"Block Group\":\n                tract_id = input(\"Enter the Census Tract number: \").strip()\n                block_group_id = input(\"Enter the Block Group number or * for all: \").strip()\n                geo_params['tract_id'] = tract_id\n                geo_params['block_group_id'] = block_group_id\n            elif geography == \"Block\":\n                tract_id = input(\"Enter the Census Tract number: \").strip()\n                block_group_id = input(\"Enter the Block Group number: \").strip()\n                block_id = input(\"Enter the Block number or * for all: \").strip()\n                geo_params['tract_id'] = tract_id\n                geo_params['block_group_id'] = block_group_id\n                geo_params['block_id'] = block_id\n\n        # Ask about CSV export\n        export_csv = input(\"Would you like to export the data to CSV? (y/n): \").strip().lower() == 'y'\n        output_dir = None\n        if export_csv:\n            output_dir = input(\"Enter output directory path (leave blank for current directory): \").strip()\n            if not output_dir:\n                output_dir = os.getcwd()\n            if not os.path.exists(output_dir):\n                os.makedirs(output_dir)\n\n        # Initialize Census client\n        c = Census(api_key)\n\n        # Dictionary to hold DataFrames for each year\n        dfs = {}\n\n        for year in years:\n            print(f\"\\nProcessing year {year}...\")\n\n            try:\n                # Get metadata and variable labels\n                metadata_url = f\"https://api.census.gov/data/{year}/acs/{acs_survey}/variables.json\"\n                metadata_response = requests.get(metadata_url)\n                if metadata_response.status_code != 200:\n                    print(f\"Warning: Failed to get table metadata for year {year}: {metadata_response.text}\")\n                    continue\n\n                variables = metadata_response.json()['variables']\n                fields = [var for var in variables if var.startswith(f\"{table}_\") and var.endswith(\"E\")]\n\n                if not fields:\n                    print(f\"Warning: No variables found for table {table} in year {year}\")\n                    continue\n\n                # Build a label mapping for renaming columns later\n                field_label_map = {\n                    var: variables[var]['label'].replace(\"Estimate!!\", \"\").replace(\"Estimate: \", \"\").strip()\n                    for var in fields\n                }\n\n                # Fetch data based on geography\n                data = self.get_acs_data_manually(\n                    c, acs_survey, geography, year, fields, state_fips, geo_params\n                )\n\n                if data is None:\n                    print(f\"Warning: No data retrieved for year {year}\")\n                    continue\n\n                print(f\"Successfully retrieved {len(data)} records for year {year}.\")\n\n                # Convert to DataFrame\n                df = pd.DataFrame(data)\n\n                # Rename ACS variable columns to descriptive labels\n                df.rename(columns=field_label_map, inplace=True)\n\n                # Sort columns: data fields first, geographic identifiers last\n                geo_cols = [col for col in df.columns if any(geo in col.lower() for geo in \n                            ['state', 'county', 'tract', 'block', 'place', 'zip', 'msa'])]\n                data_cols = sorted([col for col in df.columns if col not in geo_cols])\n                df = df[data_cols + geo_cols]\n\n                # Add year column\n                df['year'] = year\n\n                # Store DataFrame\n                dfs[year] = df\n\n                # Export to CSV if requested\n                if export_csv:\n                    filename = f\"acs_{table}_{geography.replace('/', '_')}_{year}.csv\"\n                    filepath = os.path.join(output_dir, filename)\n                    df.to_csv(filepath, index=False)\n                    print(f\"Data for year {year} saved to {filepath}\")\n\n            except Exception as e:\n                print(f\"Error processing year {year}: {str(e)}\")\n                continue\n\n            # Return appropriate result based on number of years requested\n            if len(years) == 1:\n                return dfs.get(years[0], pd.DataFrame())\n            return dfs\n\n    def get_acs_data_manually(self, c, acs_survey, geography, year, fields, state_fips, geo_params):\n        \"\"\"Fetch raw Census data for given parameters (renamed from fetch_geography_data).\"\"\"\n        if geography == \"Nation\":\n            print(\"Fetching data for the Nation...\")\n            return getattr(c, acs_survey).us(fields, year=year)\n\n        elif geography == \"State\":\n            print(\"Fetching data at State level...\")\n            return getattr(c, acs_survey).state(fields, state_fips, year=year)\n\n        elif geography == \"County\":\n            county_name = geo_params.get('county_name', '*')\n            if county_name == '*':\n                print(\"Fetching data for all counties...\")\n                return getattr(c, acs_survey).state_county(fields, state_fips, \"*\", year=year)\n            else:\n                counties_url = f'https://api.census.gov/data/{year}/acs/{acs_survey}?get=NAME&amp;for=county:*&amp;in=state:{state_fips}'\n                response = requests.get(counties_url)\n                if response.status_code != 200:\n                    raise RuntimeError(f\"Failed to fetch counties: {response.text}\")\n                counties_data = response.json()[1:]\n                county_fips = next((row[2] for row in counties_data if county_name.lower() in row[0].lower()), None)\n                if not county_fips:\n                    raise ValueError(f\"County '{county_name}' not found.\")\n                print(f\"Fetching data for {county_name} County...\")\n                return getattr(c, acs_survey).state_county(fields, state_fips, county_fips, year=year)\n\n        # Handle other geography types (Place, Tract, etc.)\n        elif geography == \"Place\":\n            place_id = geo_params.get('place_id', '*')\n            print(f\"Fetching data for Place ID: {place_id}\")\n            return getattr(c, acs_survey).state_place(fields, state_fips, place_id, year=year)\n\n        elif geography == \"Census Tract\":\n            tract_id = geo_params.get('tract_id', '*')\n            county_name = geo_params['county_name']\n            print(f\"Fetching data for Census Tract: {tract_id} in {county_name} County\")\n            return getattr(c, acs_survey).state_county_tract(fields, state_fips, county_name, tract_id, year=year)\n\n        # Add other geography types as needed\n        else:\n            raise ValueError(f\"Unsupported geography type: {geography}\")\n\n    def get_acs_data_manually_programmatic(self, c, acs_survey, geography, year, fields, \n                                         state_fips, geo_params, save_csv=False, \n                                         output_dir=None):\n        \"\"\"Programmatic version of ACS data fetcher (no user prompts).\"\"\"\n        # Fetch the raw data using the renamed method\n        raw_data = self.get_acs_data_manually(\n            c, acs_survey, geography, year, fields, state_fips, geo_params\n        )\n\n        if not raw_data:\n            print(f\"No data returned for {geography} in {year}\")\n            return pd.DataFrame()\n\n        # Convert to DataFrame\n        df = pd.DataFrame(raw_data)\n\n        # Add metadata columns\n        df['year'] = year\n        df['survey'] = acs_survey\n        df['geography'] = geography\n\n        # Save to CSV if requested\n        if save_csv:\n            output_dir = output_dir or os.getcwd()\n            os.makedirs(output_dir, exist_ok=True)\n\n            filename = f\"acs_{year}_{acs_survey}_{geography.replace('/', '_')}.csv\"\n            filepath = os.path.join(output_dir, filename)\n            df.to_csv(filepath, index=False)\n            print(f\"Data saved to {filepath}\")\n\n        return df\n</code></pre>"},{"location":"homestock/#homestock.homestock.CensusData.__init__","title":"<code>__init__(self, table_file='acs_tables.csv')</code>  <code>special</code>","text":"<p>Initialize CensusData with optional custom table file.</p> <p>Parameters:</p> Name Type Description Default <code>table_file</code> <code>str</code> <p>Filename of ACS tables CSV. Defaults to \"acs_tables.csv\".</p> <code>'acs_tables.csv'</code> Source code in <code>homestock/homestock.py</code> <pre><code>def __init__(self, table_file=\"acs_tables.csv\"):\n    \"\"\"Initialize CensusData with optional custom table file.\n\n    Args:\n        table_file (str): Filename of ACS tables CSV. Defaults to \"acs_tables.csv\".\n    \"\"\"\n    # Get absolute path to the CSV file\n    self.table_path = Path(__file__).parent / table_file\n\n    # Verify file exists at initialization\n    if not self.table_path.exists():\n        raise FileNotFoundError(f\"ACS tables file not found at: {self.table_path}\")\n</code></pre>"},{"location":"homestock/#homestock.homestock.CensusData.get_acs_data","title":"<code>get_acs_data()</code>","text":"<p>Fetch ACS data at various geographic levels with interactive prompts.</p> <p>Prompts user for inputs, fetches ACS data at various geographic levels,  supports multiple years, and offers CSV export option.</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>If one year requested dict: Dictionary of {year: pd.DataFrame} if multiple years requested</p> <p>This interactive function prompts for:</p> <ul> <li>API Key (required)</li> <li>Table ID (e.g., \"B19001\")</li> <li>Year(s) (comma-separated)</li> <li>Survey type (\"1\" or \"5\")</li> <li>Geography level</li> <li>State/county details (when applicable)</li> <li>CSV export options</li> </ul> Source code in <code>homestock/homestock.py</code> <pre><code>def get_acs_data():\n    \"\"\"Fetch ACS data at various geographic levels with interactive prompts.\n\n    Prompts user for inputs, fetches ACS data at various geographic levels, \n    supports multiple years, and offers CSV export option.\n\n    Returns:\n        pd.DataFrame: If one year requested\n        dict: Dictionary of {year: pd.DataFrame} if multiple years requested\n\n    Note: This interactive function prompts for:\n        - API Key (required)\n        - Table ID (e.g., \"B19001\")\n        - Year(s) (comma-separated)\n        - Survey type (\"1\" or \"5\")\n        - Geography level\n        - State/county details (when applicable)\n        - CSV export options\n    \"\"\"\n    print(\"Welcome to the ACS Data Fetcher!\")\n\n    # Get API key\n    api_key = input(\"Enter your Census API key: \").strip()\n    if not api_key:\n        raise ValueError(\"API key is required.\")\n\n    # Get table ID\n    table = input(\"Enter the ACS table ID (e.g., B19001): \").strip().upper()\n    if not table:\n        raise ValueError(\"Table ID is required.\")\n\n    # Get year(s) - support for multiple years\n    year_input = input(\"Enter ACS year(s) (comma-separated for multiple, e.g., 2018,2019,2020): \").strip()\n    if not year_input:\n        years = [2020]\n    else:\n        try:\n            years = [int(y.strip()) for y in year_input.split(\",\")]\n        except ValueError:\n            raise ValueError(\"Years must be comma-separated integers (e.g., '2018,2019,2020')\")\n\n    # Get survey type\n    survey_type = input(\"Enter survey type ('5' for ACS 5-year, '1' for ACS 1-year): \").strip()\n    if survey_type not in {'1', '5'}:\n        raise ValueError(\"Survey type must be '1' or '5'.\")\n    acs_survey = f\"acs{survey_type}\"\n\n    # Get geography level\n    valid_geographies = {\n        \"acs5\": [\n            \"Nation\", \"State\", \"County\", \"County Subdivision\", \"Place\", \"ZIP Code Tabulation Area\",\n            \"Metropolitan/Micropolitan Statistical Area\", \"Census Tract\", \"Block\", \"Block Group\"\n        ],\n        \"acs1\": [\n            \"Nation\", \"State\", \"County\", \"Metropolitan/Micropolitan Statistical Area\", \"Place\"\n        ]\n    }\n\n    print(f\"\\nAvailable geographic levels for {acs_survey}:\")\n    for idx, geo in enumerate(valid_geographies[acs_survey], 1):\n        print(f\"{idx}. {geo}\")\n\n    geo_selection = input(\"Enter the number corresponding to your desired geographic level: \").strip()\n    if not geo_selection.isdigit() or int(geo_selection) not in range(1, len(valid_geographies[acs_survey]) + 1):\n        raise ValueError(\"Invalid selection. Please enter a number from the list.\")\n\n    geography = valid_geographies[acs_survey][int(geo_selection) - 1]\n    print(f\"You selected: {geography}\")\n\n    # Get state input if needed\n    state_fips = None\n    state_name = None\n    if geography in [\"State\", \"County\", \"County Subdivision\", \"Place\", \"ZIP Code Tabulation Area\", \n                    \"Census Tract\", \"Block\", \"Block Group\"]:\n        state_name = input(\"Enter the full state name (e.g., Tennessee): \").strip()\n        state_obj = us.states.lookup(state_name)\n        if not state_obj:\n            raise ValueError(f\"Invalid state name: {state_name}\")\n        state_fips = state_obj.fips\n\n    # Get additional geography-specific inputs\n    geo_params = {}\n    if geography == \"County\":\n        county_name = input(\"Enter the county name (e.g., Knox) or * for all counties: \").strip()\n        geo_params['county_name'] = county_name\n    elif geography == \"Place\":\n        place_id = input(\"Enter the Place ID or * for all places in the state: \").strip()\n        geo_params['place_id'] = place_id\n    elif geography == \"Metropolitan/Micropolitan Statistical Area\":\n        metro_id = input(\"Enter the Metro/Micro area ID: \").strip()\n        geo_params['metro_id'] = metro_id\n    elif geography == \"ZIP Code Tabulation Area\":\n        zip_id = input(\"Enter the ZIP Code Tabulation Area ID or * for all: \").strip()\n        geo_params['zip_id'] = zip_id\n    elif geography in [\"Census Tract\", \"Block Group\", \"Block\"]:\n        county_name = input(\"Enter the county name (e.g., Knox) or * for all counties: \").strip()\n        geo_params['county_name'] = county_name\n        if geography == \"Census Tract\":\n            tract_id = input(\"Enter the Census Tract number or * for all tracts in this county: \").strip()\n            geo_params['tract_id'] = tract_id\n        elif geography == \"Block Group\":\n            tract_id = input(\"Enter the Census Tract number: \").strip()\n            block_group_id = input(\"Enter the Block Group number or * for all: \").strip()\n            geo_params['tract_id'] = tract_id\n            geo_params['block_group_id'] = block_group_id\n        elif geography == \"Block\":\n            tract_id = input(\"Enter the Census Tract number: \").strip()\n            block_group_id = input(\"Enter the Block Group number: \").strip()\n            block_id = input(\"Enter the Block number or * for all: \").strip()\n            geo_params['tract_id'] = tract_id\n            geo_params['block_group_id'] = block_group_id\n            geo_params['block_id'] = block_id\n\n    # Ask about CSV export\n    export_csv = input(\"Would you like to export the data to CSV? (y/n): \").strip().lower() == 'y'\n    output_dir = None\n    if export_csv:\n        output_dir = input(\"Enter output directory path (leave blank for current directory): \").strip()\n        if not output_dir:\n            output_dir = os.getcwd()\n        if not os.path.exists(output_dir):\n            os.makedirs(output_dir)\n\n    # Initialize Census client\n    c = Census(api_key)\n\n    # Dictionary to hold DataFrames for each year\n    dfs = {}\n\n    for year in years:\n        print(f\"\\nProcessing year {year}...\")\n\n        try:\n            # Get metadata and variable labels\n            metadata_url = f\"https://api.census.gov/data/{year}/acs/{acs_survey}/variables.json\"\n            metadata_response = requests.get(metadata_url)\n            if metadata_response.status_code != 200:\n                print(f\"Warning: Failed to get table metadata for year {year}: {metadata_response.text}\")\n                continue\n\n            variables = metadata_response.json()['variables']\n            fields = [var for var in variables if var.startswith(f\"{table}_\") and var.endswith(\"E\")]\n\n            if not fields:\n                print(f\"Warning: No variables found for table {table} in year {year}\")\n                continue\n\n            # Build a label mapping for renaming columns later\n            field_label_map = {\n                var: variables[var]['label'].replace(\"Estimate!!\", \"\").replace(\"Estimate: \", \"\").strip()\n                for var in fields\n            }\n\n            # Fetch data based on geography\n            data = self.get_acs_data_manually(\n                c, acs_survey, geography, year, fields, state_fips, geo_params\n            )\n\n            if data is None:\n                print(f\"Warning: No data retrieved for year {year}\")\n                continue\n\n            print(f\"Successfully retrieved {len(data)} records for year {year}.\")\n\n            # Convert to DataFrame\n            df = pd.DataFrame(data)\n\n            # Rename ACS variable columns to descriptive labels\n            df.rename(columns=field_label_map, inplace=True)\n\n            # Sort columns: data fields first, geographic identifiers last\n            geo_cols = [col for col in df.columns if any(geo in col.lower() for geo in \n                        ['state', 'county', 'tract', 'block', 'place', 'zip', 'msa'])]\n            data_cols = sorted([col for col in df.columns if col not in geo_cols])\n            df = df[data_cols + geo_cols]\n\n            # Add year column\n            df['year'] = year\n\n            # Store DataFrame\n            dfs[year] = df\n\n            # Export to CSV if requested\n            if export_csv:\n                filename = f\"acs_{table}_{geography.replace('/', '_')}_{year}.csv\"\n                filepath = os.path.join(output_dir, filename)\n                df.to_csv(filepath, index=False)\n                print(f\"Data for year {year} saved to {filepath}\")\n\n        except Exception as e:\n            print(f\"Error processing year {year}: {str(e)}\")\n            continue\n\n        # Return appropriate result based on number of years requested\n        if len(years) == 1:\n            return dfs.get(years[0], pd.DataFrame())\n        return dfs\n</code></pre>"},{"location":"homestock/#homestock.homestock.CensusData.get_acs_data_manually","title":"<code>get_acs_data_manually(self, c, acs_survey, geography, year, fields, state_fips, geo_params)</code>","text":"<p>Fetch raw Census data for given parameters (renamed from fetch_geography_data).</p> Source code in <code>homestock/homestock.py</code> <pre><code>def get_acs_data_manually(self, c, acs_survey, geography, year, fields, state_fips, geo_params):\n    \"\"\"Fetch raw Census data for given parameters (renamed from fetch_geography_data).\"\"\"\n    if geography == \"Nation\":\n        print(\"Fetching data for the Nation...\")\n        return getattr(c, acs_survey).us(fields, year=year)\n\n    elif geography == \"State\":\n        print(\"Fetching data at State level...\")\n        return getattr(c, acs_survey).state(fields, state_fips, year=year)\n\n    elif geography == \"County\":\n        county_name = geo_params.get('county_name', '*')\n        if county_name == '*':\n            print(\"Fetching data for all counties...\")\n            return getattr(c, acs_survey).state_county(fields, state_fips, \"*\", year=year)\n        else:\n            counties_url = f'https://api.census.gov/data/{year}/acs/{acs_survey}?get=NAME&amp;for=county:*&amp;in=state:{state_fips}'\n            response = requests.get(counties_url)\n            if response.status_code != 200:\n                raise RuntimeError(f\"Failed to fetch counties: {response.text}\")\n            counties_data = response.json()[1:]\n            county_fips = next((row[2] for row in counties_data if county_name.lower() in row[0].lower()), None)\n            if not county_fips:\n                raise ValueError(f\"County '{county_name}' not found.\")\n            print(f\"Fetching data for {county_name} County...\")\n            return getattr(c, acs_survey).state_county(fields, state_fips, county_fips, year=year)\n\n    # Handle other geography types (Place, Tract, etc.)\n    elif geography == \"Place\":\n        place_id = geo_params.get('place_id', '*')\n        print(f\"Fetching data for Place ID: {place_id}\")\n        return getattr(c, acs_survey).state_place(fields, state_fips, place_id, year=year)\n\n    elif geography == \"Census Tract\":\n        tract_id = geo_params.get('tract_id', '*')\n        county_name = geo_params['county_name']\n        print(f\"Fetching data for Census Tract: {tract_id} in {county_name} County\")\n        return getattr(c, acs_survey).state_county_tract(fields, state_fips, county_name, tract_id, year=year)\n\n    # Add other geography types as needed\n    else:\n        raise ValueError(f\"Unsupported geography type: {geography}\")\n</code></pre>"},{"location":"homestock/#homestock.homestock.CensusData.get_acs_data_manually_programmatic","title":"<code>get_acs_data_manually_programmatic(self, c, acs_survey, geography, year, fields, state_fips, geo_params, save_csv=False, output_dir=None)</code>","text":"<p>Programmatic version of ACS data fetcher (no user prompts).</p> Source code in <code>homestock/homestock.py</code> <pre><code>def get_acs_data_manually_programmatic(self, c, acs_survey, geography, year, fields, \n                                     state_fips, geo_params, save_csv=False, \n                                     output_dir=None):\n    \"\"\"Programmatic version of ACS data fetcher (no user prompts).\"\"\"\n    # Fetch the raw data using the renamed method\n    raw_data = self.get_acs_data_manually(\n        c, acs_survey, geography, year, fields, state_fips, geo_params\n    )\n\n    if not raw_data:\n        print(f\"No data returned for {geography} in {year}\")\n        return pd.DataFrame()\n\n    # Convert to DataFrame\n    df = pd.DataFrame(raw_data)\n\n    # Add metadata columns\n    df['year'] = year\n    df['survey'] = acs_survey\n    df['geography'] = geography\n\n    # Save to CSV if requested\n    if save_csv:\n        output_dir = output_dir or os.getcwd()\n        os.makedirs(output_dir, exist_ok=True)\n\n        filename = f\"acs_{year}_{acs_survey}_{geography.replace('/', '_')}.csv\"\n        filepath = os.path.join(output_dir, filename)\n        df.to_csv(filepath, index=False)\n        print(f\"Data saved to {filepath}\")\n\n    return df\n</code></pre>"},{"location":"homestock/#homestock.homestock.CensusData.search_census_tables","title":"<code>search_census_tables(self, keyword=None)</code>","text":"<p>Search the Census tables based on a keyword.</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>Keyword to search in table titles. If None, prompts user.</p> <code>None</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>Contains columns 'Table ID', 'Table Title', and 'Year'.</p> Source code in <code>homestock/homestock.py</code> <pre><code>def search_census_tables(self, keyword=None):\n    \"\"\"Search the Census tables based on a keyword.\n\n    Args:\n        keyword (str, optional): Keyword to search in table titles. If None, prompts user.\n\n    Returns:\n        pd.DataFrame: Contains columns 'Table ID', 'Table Title', and 'Year'.\n    \"\"\"\n    # Get keyword input if not provided\n    if keyword is None:\n        keyword = input(\"Enter a keyword to search Census tables: \").lower()\n\n    matching_tables = []\n\n    # Read data using absolute path\n    with open(self.table_path, mode=\"r\", encoding=\"utf-8\") as file:\n        reader = csv.DictReader(file)\n        for row in reader:\n            if keyword in row[\"Table Title\"].lower():\n                matching_tables.append({\n                    \"Table ID\": row[\"Table ID\"],\n                    \"Table Title\": row[\"Table Title\"], \n                    \"Year\": row[\"Year\"]\n                })\n\n    # Convert to DataFrame\n    result = pd.DataFrame(matching_tables)\n\n    # Print formatted output\n    if not result.empty:\n        print(f\"\\nMatching Census Tables for '{keyword}':\\n\")\n        print(tabulate(result, headers=\"keys\", tablefmt=\"grid\", showindex=False))\n    else:\n        print(f\"\\nNo matching tables found for '{keyword}'\")\n\n    return result\n</code></pre>"},{"location":"homestock/#homestock.homestock.Map","title":"<code> Map            (Map)         </code>","text":"Source code in <code>homestock/homestock.py</code> <pre><code>class Map(ipyleaflet.Map):\n    def __init__(self, center=[20, 0], zoom=2, **kwargs):\n        super(Map, self).__init__(center=center, zoom=zoom, **kwargs)\n\n    def add_basemap(self, basemap=\"Esri.WorldImagery\"):\n        \"\"\"\n        Args:\n            basemap (str): Basemap name. Default is \"Esri.WorldImagery\".\n        \"\"\"\n        \"\"\"Add a basemap to the map.\"\"\"\n        basemaps = [\n            \"OpenStreetMap.Mapnik\",\n            \"Stamen.Terrain\",\n            \"Stamen.TerrainBackground\",\n            \"Stamen.Watercolor\",\n            \"Esri.WorldImagery\",\n            \"Esri.DeLorme\",\n            \"Esri.NatGeoWorldMap\",\n            \"Esri.WorldStreetMap\",\n            \"Esri.WorldTopoMap\",\n            \"Esri.WorldGrayCanvas\",\n            \"Esri.WorldShadedRelief\",\n            \"Esri.WorldPhysical\",\n            \"Esri.WorldTerrain\",\n            \"Google.Satellite\",\n            \"Google.Street\",\n            \"Google.Hybrid\",\n            \"Google.Terrain\",\n        ]\n        url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n        basemap_layer = ipyleaflet.TileLayer(url=url, name=basemap)\n        self.add(basemap_layer)\n\n    def layer(self, layer) -&gt; None:\n        \"\"\"\n        Args:\n            layer (str or dict): Layer to be added to the map.\n            **kwargs: Additional arguments for the layer.\n        Returns:\n            None\n        Raises:\n            ValueError: If the layer is not a valid type.\n        \"\"\"\n        \"\"\" Convert url to layer\"\"\"\n        if isinstance(layer, str):\n            layer = ipyleaflet.TileLayer(url=layer)\n        elif isinstance(layer, dict):\n            layer = ipyleaflet.GeoJSON(data=layer)\n        elif not isinstance(layer, ipyleaflet.Layer):\n            raise ValueError(\"Layer must be an instance of ipyleaflet.Layer\")\n        return layer\n\n    def add_layer_control(self, position=\"topright\") -&gt; None:\n        \"\"\"Adds a layer control to the map.\n\n        Args:\n            position (str, optional): The position of the layer control. Defaults to 'topright'.\n        \"\"\"\n\n        self.add(ipyleaflet.LayersControl(position=position))\n\n    def add_geojson(self, geojson, **kwargs):\n        \"\"\"\n        Args:\n            geojson (dict): GeoJSON data.\n            **kwargs: Additional arguments for the GeoJSON layer.\n        \"\"\"\n        \"\"\"Add a GeoJSON layer to the map.\"\"\"\n        geojson_layer = ipyleaflet.GeoJSON(data=geojson, **kwargs)\n        self.add(geojson_layer)\n\n    def set_center(self, lat, lon, zoom=6, **kwargs):\n        \"\"\"\n        Args:\n            lat (float): Latitude of the center.\n            lon (float): Longitude of the center.\n            zoom (int): Zoom level.\n            **kwargs: Additional arguments for the map.\n        \"\"\"\n        \"\"\"Set the center of the map.\"\"\"\n        self.center = (lat, lon)\n        self.zoom = zoom\n\n    def center_object(self, obj, zoom=6, **kwargs):\n        \"\"\"\n        Args:\n            obj (str or dict): Object to center the map on.\n            zoom (int): Zoom level.\n            **kwargs: Additional arguments for the map.\n        \"\"\"\n        \"\"\"Center the map on an object.\"\"\"\n        if isinstance(obj, str):\n            obj = ipyleaflet.GeoJSON(data=obj, **kwargs)\n        elif not isinstance(obj, ipyleaflet.Layer):\n            raise ValueError(\"Object must be an instance of ipyleaflet.Layer\")\n        self.center = (obj.location[0], obj.location[1])\n        self.zoom = zoom\n\n    def add_vector(self, vector, **kwargs):\n        \"\"\"\n        Args:\n            vector (dict): Vector data.\n            **kwargs: Additional arguments for the GeoJSON layer.\n        \"\"\"\n        \"\"\"Add a vector layer to the map from Geopandas.\"\"\"\n        vector_layer = ipyleaflet.GeoJSON(data=vector, **kwargs)\n        self.add(vector_layer)\n\n    def add_raster(self, filepath, name=None, colormap=\"greys\", opacity=1, **kwargs):\n        \"\"\"\n        Add a raster (COG) layer to the map.\n\n        Parameters:\n        filepath (str): Path or URL to the cloud-optimized GeoTIFF (COG).\n        name (str, optional): Display name for the layer.\n        colormap (dict or str, optional): A colormap dictionary or a string identifier.\n        opacity (float, optional): Transparency level (default is 1 for fully opaque).\n        **kwargs: Additional keyword arguments to pass to the tile layer generator.\n        \"\"\"\n        import rasterio\n        from localtileserver import TileClient, get_leaflet_tile_layer\n\n        # Open the raster with rasterio to inspect metadata.\n        with rasterio.open(filepath) as src:\n            # If no colormap is provided (i.e., None), try extracting it from the raster's first band.\n            if colormap is None:\n                try:\n                    colormap = src.colormap(1)\n                except Exception:\n                    # Leave colormap unchanged if extraction fails.\n                    colormap = \"greys\"\n\n        # Create the tile client from the provided file path.\n        client = TileClient(filepath)\n\n        # Generate the leaflet tile layer using the provided parameters.\n        tile_layer = get_leaflet_tile_layer(\n            client, name=name, colormap=colormap, opacity=opacity, **kwargs\n        )\n\n        # Add the layer to the viewer and update the center and zoom based on the raster metadata.\n        self.add(tile_layer)\n\n    def add_image(self, url, bounds, opacity=1, **kwargs):\n        \"\"\"\n        Adds an image or animated GIF overlay to the map.\n\n        Parameters:\n            url (str): The URL of the image or GIF.\n            bounds (tuple): Geographic coordinates as ((south, west), (north, east)).\n            opacity (float, optional): The transparency level of the overlay (default is 1, fully opaque).\n            **kwargs: Additional keyword arguments for ipyleaflet.ImageOverlay.\n\n        Raises:\n            ValueError: If bounds is not provided or is improperly formatted.\n        \"\"\"\n\n        # Validate bounds: It should be a tuple of two coordinate tuples, each of length 2.\n        if not (\n            isinstance(bounds, tuple)\n            and len(bounds) == 2\n            and all(isinstance(coord, tuple) and len(coord) == 2 for coord in bounds)\n        ):\n            raise ValueError(\n                \"bounds must be a tuple in the format ((south, west), (north, east))\"\n            )\n\n        # Create the image overlay using ipyleaflet.ImageOverlay.\n        overlay = ipyleaflet.ImageOverlay(\n            url=url, bounds=bounds, opacity=opacity, **kwargs\n        )\n\n        # Add the overlay to the map.\n        self.add(overlay)\n        self.center = [\n            (bounds[0][0] + bounds[1][0]) / 2,\n            (bounds[0][1] + bounds[1][1]) / 2,\n        ]\n\n    def add_video(self, url, bounds, opacity=1.0, **kwargs):\n        \"\"\"\n        Adds a video overlay to the map using ipyleaflet.VideoOverlay.\n\n        Parameters:\n            url (str or list): The URL or list of URLs for the video file(s).\n            bounds (tuple): Geographic bounds in the format ((south, west), (north, east)).\n            opacity (float): Transparency level of the overlay (0 = fully transparent, 1 = fully opaque).\n            **kwargs: Additional keyword arguments for ipyleaflet.VideoOverlay.\n        \"\"\"\n\n        # Validate and normalize bounds format\n        if not (\n            isinstance(bounds, (tuple, list))\n            and len(bounds) == 2\n            and all(\n                isinstance(coord, (tuple, list)) and len(coord) == 2 for coord in bounds\n            )\n        ):\n            raise ValueError(\n                \"bounds must be provided as ((south, west), (north, east))\"\n            )\n\n        # Convert bounds to tuple of tuples\n        bounds = tuple(tuple(coord) for coord in bounds)\n\n        # Create and add the VideoOverlay\n        overlay = VideoOverlay(url=url, bounds=bounds, opacity=opacity, **kwargs)\n        self.add(overlay)\n\n        # Center the map on the video bounds\n        south, west = bounds[0]\n        north, east = bounds[1]\n        self.center = [(south + north) / 2, (west + east) / 2]\n\n    def add_wms_layer(self, url, layers, name, format, transparent, **kwargs):\n        \"\"\"\n        Adds a WMS (Web Map Service) layer to the map using ipyleaflet.WMSLayer.\n\n        Parameters:\n            url (str): Base WMS endpoint.\n            layers (str): Comma-separated layer names.\n            name (str): Display name for the layer.\n            format (str): Image format (e.g., 'image/png').\n            transparent (bool): Whether the WMS layer should be transparent.\n            **kwargs: Additional keyword arguments for ipyleaflet.WMSLayer.\n        \"\"\"\n\n        # Create the WMS layer using the provided parameters.\n        wms_layer = WMSLayer(\n            url=url,\n            layers=layers,\n            name=name,\n            format=format,\n            transparent=transparent,\n            **kwargs,\n        )\n\n        # Add the WMS layer to the map.\n        self.add(wms_layer)\n\n    def add_basemap_dropdown(self):\n        \"\"\"\n        Adds a dropdown + hide button as a map control.\n        Keeps track of the current basemap layer so that selecting\n        a new one removes the old and adds the new immediately.\n\n        Returns:\n            None\n        \"\"\"\n        # 1. define your choices\n        basemap_dict = {\n            \"OpenStreetMap\": basemaps.OpenStreetMap.Mapnik,\n            \"OpenTopoMap\": basemaps.OpenTopoMap,\n            \"Esri.WorldImagery\": basemaps.Esri.WorldImagery,\n            \"CartoDB.DarkMatter\": basemaps.CartoDB.DarkMatter,\n        }\n\n        # 2. build widgets\n        dropdown = widgets.Dropdown(\n            options=list(basemap_dict.keys()),\n            value=\"OpenStreetMap\",\n            layout={\"width\": \"180px\"},\n            description=\"Basemap:\",\n        )\n        hide_btn = widgets.Button(description=\"Hide\", button_style=\"danger\")\n        container = widgets.VBox([dropdown, hide_btn])\n\n        # 3. add the initial basemap layer and remember it\n        initial = basemap_dict[dropdown.value]\n        self._current_basemap = basemap_to_tiles(initial)\n        self.add_layer(self._current_basemap)\n\n        # 4. when user picks a new basemap, swap layers\n        def _on_change(change):\n            if change[\"name\"] == \"value\":\n                new_tiles = basemap_to_tiles(basemap_dict[change[\"new\"]])\n                # remove old\n                self.remove_layer(self._current_basemap)\n                # add new &amp; store reference\n                self._current_basemap = new_tiles\n                self.add_layer(self._current_basemap)\n\n        dropdown.observe(_on_change, names=\"value\")\n\n        # 5. hide control if needed\n        hide_btn.on_click(lambda _: setattr(container.layout, \"display\", \"none\"))\n\n        # 6. wrap in a WidgetControl and add to map\n        ctrl = WidgetControl(widget=container, position=\"topright\")\n        self.add_control(ctrl)\n</code></pre>"},{"location":"homestock/#homestock.homestock.Map.add_basemap","title":"<code>add_basemap(self, basemap='Esri.WorldImagery')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Basemap name. Default is \"Esri.WorldImagery\".</p> <code>'Esri.WorldImagery'</code> Source code in <code>homestock/homestock.py</code> <pre><code>def add_basemap(self, basemap=\"Esri.WorldImagery\"):\n    \"\"\"\n    Args:\n        basemap (str): Basemap name. Default is \"Esri.WorldImagery\".\n    \"\"\"\n    \"\"\"Add a basemap to the map.\"\"\"\n    basemaps = [\n        \"OpenStreetMap.Mapnik\",\n        \"Stamen.Terrain\",\n        \"Stamen.TerrainBackground\",\n        \"Stamen.Watercolor\",\n        \"Esri.WorldImagery\",\n        \"Esri.DeLorme\",\n        \"Esri.NatGeoWorldMap\",\n        \"Esri.WorldStreetMap\",\n        \"Esri.WorldTopoMap\",\n        \"Esri.WorldGrayCanvas\",\n        \"Esri.WorldShadedRelief\",\n        \"Esri.WorldPhysical\",\n        \"Esri.WorldTerrain\",\n        \"Google.Satellite\",\n        \"Google.Street\",\n        \"Google.Hybrid\",\n        \"Google.Terrain\",\n    ]\n    url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n    basemap_layer = ipyleaflet.TileLayer(url=url, name=basemap)\n    self.add(basemap_layer)\n</code></pre>"},{"location":"homestock/#homestock.homestock.Map.add_basemap_dropdown","title":"<code>add_basemap_dropdown(self)</code>","text":"<p>Adds a dropdown + hide button as a map control. Keeps track of the current basemap layer so that selecting a new one removes the old and adds the new immediately.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>homestock/homestock.py</code> <pre><code>def add_basemap_dropdown(self):\n    \"\"\"\n    Adds a dropdown + hide button as a map control.\n    Keeps track of the current basemap layer so that selecting\n    a new one removes the old and adds the new immediately.\n\n    Returns:\n        None\n    \"\"\"\n    # 1. define your choices\n    basemap_dict = {\n        \"OpenStreetMap\": basemaps.OpenStreetMap.Mapnik,\n        \"OpenTopoMap\": basemaps.OpenTopoMap,\n        \"Esri.WorldImagery\": basemaps.Esri.WorldImagery,\n        \"CartoDB.DarkMatter\": basemaps.CartoDB.DarkMatter,\n    }\n\n    # 2. build widgets\n    dropdown = widgets.Dropdown(\n        options=list(basemap_dict.keys()),\n        value=\"OpenStreetMap\",\n        layout={\"width\": \"180px\"},\n        description=\"Basemap:\",\n    )\n    hide_btn = widgets.Button(description=\"Hide\", button_style=\"danger\")\n    container = widgets.VBox([dropdown, hide_btn])\n\n    # 3. add the initial basemap layer and remember it\n    initial = basemap_dict[dropdown.value]\n    self._current_basemap = basemap_to_tiles(initial)\n    self.add_layer(self._current_basemap)\n\n    # 4. when user picks a new basemap, swap layers\n    def _on_change(change):\n        if change[\"name\"] == \"value\":\n            new_tiles = basemap_to_tiles(basemap_dict[change[\"new\"]])\n            # remove old\n            self.remove_layer(self._current_basemap)\n            # add new &amp; store reference\n            self._current_basemap = new_tiles\n            self.add_layer(self._current_basemap)\n\n    dropdown.observe(_on_change, names=\"value\")\n\n    # 5. hide control if needed\n    hide_btn.on_click(lambda _: setattr(container.layout, \"display\", \"none\"))\n\n    # 6. wrap in a WidgetControl and add to map\n    ctrl = WidgetControl(widget=container, position=\"topright\")\n    self.add_control(ctrl)\n</code></pre>"},{"location":"homestock/#homestock.homestock.Map.add_geojson","title":"<code>add_geojson(self, geojson, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>geojson</code> <code>dict</code> <p>GeoJSON data.</p> required <code>**kwargs</code> <p>Additional arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>homestock/homestock.py</code> <pre><code>def add_geojson(self, geojson, **kwargs):\n    \"\"\"\n    Args:\n        geojson (dict): GeoJSON data.\n        **kwargs: Additional arguments for the GeoJSON layer.\n    \"\"\"\n    \"\"\"Add a GeoJSON layer to the map.\"\"\"\n    geojson_layer = ipyleaflet.GeoJSON(data=geojson, **kwargs)\n    self.add(geojson_layer)\n</code></pre>"},{"location":"homestock/#homestock.homestock.Map.add_image","title":"<code>add_image(self, url, bounds, opacity=1, **kwargs)</code>","text":"<p>Adds an image or animated GIF overlay to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the image or GIF.</p> required <code>bounds</code> <code>tuple</code> <p>Geographic coordinates as ((south, west), (north, east)).</p> required <code>opacity</code> <code>float</code> <p>The transparency level of the overlay (default is 1, fully opaque).</p> <code>1</code> <code>**kwargs</code> <p>Additional keyword arguments for ipyleaflet.ImageOverlay.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If bounds is not provided or is improperly formatted.</p> Source code in <code>homestock/homestock.py</code> <pre><code>def add_image(self, url, bounds, opacity=1, **kwargs):\n    \"\"\"\n    Adds an image or animated GIF overlay to the map.\n\n    Parameters:\n        url (str): The URL of the image or GIF.\n        bounds (tuple): Geographic coordinates as ((south, west), (north, east)).\n        opacity (float, optional): The transparency level of the overlay (default is 1, fully opaque).\n        **kwargs: Additional keyword arguments for ipyleaflet.ImageOverlay.\n\n    Raises:\n        ValueError: If bounds is not provided or is improperly formatted.\n    \"\"\"\n\n    # Validate bounds: It should be a tuple of two coordinate tuples, each of length 2.\n    if not (\n        isinstance(bounds, tuple)\n        and len(bounds) == 2\n        and all(isinstance(coord, tuple) and len(coord) == 2 for coord in bounds)\n    ):\n        raise ValueError(\n            \"bounds must be a tuple in the format ((south, west), (north, east))\"\n        )\n\n    # Create the image overlay using ipyleaflet.ImageOverlay.\n    overlay = ipyleaflet.ImageOverlay(\n        url=url, bounds=bounds, opacity=opacity, **kwargs\n    )\n\n    # Add the overlay to the map.\n    self.add(overlay)\n    self.center = [\n        (bounds[0][0] + bounds[1][0]) / 2,\n        (bounds[0][1] + bounds[1][1]) / 2,\n    ]\n</code></pre>"},{"location":"homestock/#homestock.homestock.Map.add_layer_control","title":"<code>add_layer_control(self, position='topright')</code>","text":"<p>Adds a layer control to the map.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>The position of the layer control. Defaults to 'topright'.</p> <code>'topright'</code> Source code in <code>homestock/homestock.py</code> <pre><code>def add_layer_control(self, position=\"topright\") -&gt; None:\n    \"\"\"Adds a layer control to the map.\n\n    Args:\n        position (str, optional): The position of the layer control. Defaults to 'topright'.\n    \"\"\"\n\n    self.add(ipyleaflet.LayersControl(position=position))\n</code></pre>"},{"location":"homestock/#homestock.homestock.Map.add_raster","title":"<code>add_raster(self, filepath, name=None, colormap='greys', opacity=1, **kwargs)</code>","text":"<p>Add a raster (COG) layer to the map.</p> <p>filepath (str): Path or URL to the cloud-optimized GeoTIFF (COG). name (str, optional): Display name for the layer. colormap (dict or str, optional): A colormap dictionary or a string identifier. opacity (float, optional): Transparency level (default is 1 for fully opaque). **kwargs: Additional keyword arguments to pass to the tile layer generator.</p> Source code in <code>homestock/homestock.py</code> <pre><code>def add_raster(self, filepath, name=None, colormap=\"greys\", opacity=1, **kwargs):\n    \"\"\"\n    Add a raster (COG) layer to the map.\n\n    Parameters:\n    filepath (str): Path or URL to the cloud-optimized GeoTIFF (COG).\n    name (str, optional): Display name for the layer.\n    colormap (dict or str, optional): A colormap dictionary or a string identifier.\n    opacity (float, optional): Transparency level (default is 1 for fully opaque).\n    **kwargs: Additional keyword arguments to pass to the tile layer generator.\n    \"\"\"\n    import rasterio\n    from localtileserver import TileClient, get_leaflet_tile_layer\n\n    # Open the raster with rasterio to inspect metadata.\n    with rasterio.open(filepath) as src:\n        # If no colormap is provided (i.e., None), try extracting it from the raster's first band.\n        if colormap is None:\n            try:\n                colormap = src.colormap(1)\n            except Exception:\n                # Leave colormap unchanged if extraction fails.\n                colormap = \"greys\"\n\n    # Create the tile client from the provided file path.\n    client = TileClient(filepath)\n\n    # Generate the leaflet tile layer using the provided parameters.\n    tile_layer = get_leaflet_tile_layer(\n        client, name=name, colormap=colormap, opacity=opacity, **kwargs\n    )\n\n    # Add the layer to the viewer and update the center and zoom based on the raster metadata.\n    self.add(tile_layer)\n</code></pre>"},{"location":"homestock/#homestock.homestock.Map.add_vector","title":"<code>add_vector(self, vector, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>vector</code> <code>dict</code> <p>Vector data.</p> required <code>**kwargs</code> <p>Additional arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>homestock/homestock.py</code> <pre><code>def add_vector(self, vector, **kwargs):\n    \"\"\"\n    Args:\n        vector (dict): Vector data.\n        **kwargs: Additional arguments for the GeoJSON layer.\n    \"\"\"\n    \"\"\"Add a vector layer to the map from Geopandas.\"\"\"\n    vector_layer = ipyleaflet.GeoJSON(data=vector, **kwargs)\n    self.add(vector_layer)\n</code></pre>"},{"location":"homestock/#homestock.homestock.Map.add_video","title":"<code>add_video(self, url, bounds, opacity=1.0, **kwargs)</code>","text":"<p>Adds a video overlay to the map using ipyleaflet.VideoOverlay.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str or list</code> <p>The URL or list of URLs for the video file(s).</p> required <code>bounds</code> <code>tuple</code> <p>Geographic bounds in the format ((south, west), (north, east)).</p> required <code>opacity</code> <code>float</code> <p>Transparency level of the overlay (0 = fully transparent, 1 = fully opaque).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional keyword arguments for ipyleaflet.VideoOverlay.</p> <code>{}</code> Source code in <code>homestock/homestock.py</code> <pre><code>def add_video(self, url, bounds, opacity=1.0, **kwargs):\n    \"\"\"\n    Adds a video overlay to the map using ipyleaflet.VideoOverlay.\n\n    Parameters:\n        url (str or list): The URL or list of URLs for the video file(s).\n        bounds (tuple): Geographic bounds in the format ((south, west), (north, east)).\n        opacity (float): Transparency level of the overlay (0 = fully transparent, 1 = fully opaque).\n        **kwargs: Additional keyword arguments for ipyleaflet.VideoOverlay.\n    \"\"\"\n\n    # Validate and normalize bounds format\n    if not (\n        isinstance(bounds, (tuple, list))\n        and len(bounds) == 2\n        and all(\n            isinstance(coord, (tuple, list)) and len(coord) == 2 for coord in bounds\n        )\n    ):\n        raise ValueError(\n            \"bounds must be provided as ((south, west), (north, east))\"\n        )\n\n    # Convert bounds to tuple of tuples\n    bounds = tuple(tuple(coord) for coord in bounds)\n\n    # Create and add the VideoOverlay\n    overlay = VideoOverlay(url=url, bounds=bounds, opacity=opacity, **kwargs)\n    self.add(overlay)\n\n    # Center the map on the video bounds\n    south, west = bounds[0]\n    north, east = bounds[1]\n    self.center = [(south + north) / 2, (west + east) / 2]\n</code></pre>"},{"location":"homestock/#homestock.homestock.Map.add_wms_layer","title":"<code>add_wms_layer(self, url, layers, name, format, transparent, **kwargs)</code>","text":"<p>Adds a WMS (Web Map Service) layer to the map using ipyleaflet.WMSLayer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Base WMS endpoint.</p> required <code>layers</code> <code>str</code> <p>Comma-separated layer names.</p> required <code>name</code> <code>str</code> <p>Display name for the layer.</p> required <code>format</code> <code>str</code> <p>Image format (e.g., 'image/png').</p> required <code>transparent</code> <code>bool</code> <p>Whether the WMS layer should be transparent.</p> required <code>**kwargs</code> <p>Additional keyword arguments for ipyleaflet.WMSLayer.</p> <code>{}</code> Source code in <code>homestock/homestock.py</code> <pre><code>def add_wms_layer(self, url, layers, name, format, transparent, **kwargs):\n    \"\"\"\n    Adds a WMS (Web Map Service) layer to the map using ipyleaflet.WMSLayer.\n\n    Parameters:\n        url (str): Base WMS endpoint.\n        layers (str): Comma-separated layer names.\n        name (str): Display name for the layer.\n        format (str): Image format (e.g., 'image/png').\n        transparent (bool): Whether the WMS layer should be transparent.\n        **kwargs: Additional keyword arguments for ipyleaflet.WMSLayer.\n    \"\"\"\n\n    # Create the WMS layer using the provided parameters.\n    wms_layer = WMSLayer(\n        url=url,\n        layers=layers,\n        name=name,\n        format=format,\n        transparent=transparent,\n        **kwargs,\n    )\n\n    # Add the WMS layer to the map.\n    self.add(wms_layer)\n</code></pre>"},{"location":"homestock/#homestock.homestock.Map.center_object","title":"<code>center_object(self, obj, zoom=6, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>obj</code> <code>str or dict</code> <p>Object to center the map on.</p> required <code>zoom</code> <code>int</code> <p>Zoom level.</p> <code>6</code> <code>**kwargs</code> <p>Additional arguments for the map.</p> <code>{}</code> Source code in <code>homestock/homestock.py</code> <pre><code>def center_object(self, obj, zoom=6, **kwargs):\n    \"\"\"\n    Args:\n        obj (str or dict): Object to center the map on.\n        zoom (int): Zoom level.\n        **kwargs: Additional arguments for the map.\n    \"\"\"\n    \"\"\"Center the map on an object.\"\"\"\n    if isinstance(obj, str):\n        obj = ipyleaflet.GeoJSON(data=obj, **kwargs)\n    elif not isinstance(obj, ipyleaflet.Layer):\n        raise ValueError(\"Object must be an instance of ipyleaflet.Layer\")\n    self.center = (obj.location[0], obj.location[1])\n    self.zoom = zoom\n</code></pre>"},{"location":"homestock/#homestock.homestock.Map.layer","title":"<code>layer(self, layer)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>layer</code> <code>str or dict</code> <p>Layer to be added to the map.</p> required <code>**kwargs</code> <p>Additional arguments for the layer.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the layer is not a valid type.</p> Source code in <code>homestock/homestock.py</code> <pre><code>def layer(self, layer) -&gt; None:\n    \"\"\"\n    Args:\n        layer (str or dict): Layer to be added to the map.\n        **kwargs: Additional arguments for the layer.\n    Returns:\n        None\n    Raises:\n        ValueError: If the layer is not a valid type.\n    \"\"\"\n    \"\"\" Convert url to layer\"\"\"\n    if isinstance(layer, str):\n        layer = ipyleaflet.TileLayer(url=layer)\n    elif isinstance(layer, dict):\n        layer = ipyleaflet.GeoJSON(data=layer)\n    elif not isinstance(layer, ipyleaflet.Layer):\n        raise ValueError(\"Layer must be an instance of ipyleaflet.Layer\")\n    return layer\n</code></pre>"},{"location":"homestock/#homestock.homestock.Map.set_center","title":"<code>set_center(self, lat, lon, zoom=6, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>lat</code> <code>float</code> <p>Latitude of the center.</p> required <code>lon</code> <code>float</code> <p>Longitude of the center.</p> required <code>zoom</code> <code>int</code> <p>Zoom level.</p> <code>6</code> <code>**kwargs</code> <p>Additional arguments for the map.</p> <code>{}</code> Source code in <code>homestock/homestock.py</code> <pre><code>def set_center(self, lat, lon, zoom=6, **kwargs):\n    \"\"\"\n    Args:\n        lat (float): Latitude of the center.\n        lon (float): Longitude of the center.\n        zoom (int): Zoom level.\n        **kwargs: Additional arguments for the map.\n    \"\"\"\n    \"\"\"Set the center of the map.\"\"\"\n    self.center = (lat, lon)\n    self.zoom = zoom\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install homestock, run this command in your terminal:</p> <pre><code>pip install homestock\n</code></pre> <p>This is the preferred method to install homestock, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install homestock from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/jpepper19/homestock\n</code></pre>"},{"location":"map_folium/","title":"Map folium","text":"<p>homestock module</p> In\u00a0[1]: Copied! <pre>import folium\nimport geopandas as gpd\nimport os\n</pre> import folium import geopandas as gpd import os In\u00a0[2]: Copied! <pre>class Map:\n    \"\"\"\n    A custom folium-based map class for the homestock package,\n    supporting basemaps, layer control, and vector data visualization.\n    \"\"\"\n\n    def __init__(self, location=(0, 0), zoom_start=2):\n        \"\"\"\n        Initialize the Map.\n\n        Parameters:\n        ----------\n        location : tuple\n            Center of the map in (lat, lon).\n        zoom_start : int\n            Initial zoom level.\n        \"\"\"\n        self.map = folium.Map(location=location, zoom_start=zoom_start)\n        self._layers = []\n\n    def add_basemap(self, basemap_name: str):\n        \"\"\"\n        Add a basemap to the map.\n\n        Parameters:\n        ----------\n        basemap_name : str\n            Name of the basemap. Supported values:\n            \"OpenStreetMap\", \"Esri.WorldImagery\", \"OpenTopoMap\".\n\n        Returns:\n        -------\n        None\n        \"\"\"\n        tile_dict = {\n            \"OpenStreetMap\": \"OpenStreetMap\",\n            \"Esri.WorldImagery\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\",\n            \"OpenTopoMap\": \"https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png\",\n        }\n\n        attr_dict = {\n            \"Esri.WorldImagery\": \"Tiles \u00a9 Esri \u2014 Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye\",\n            \"OpenTopoMap\": \"\u00a9 OpenTopoMap (CC-BY-SA)\",\n        }\n\n        if basemap_name not in tile_dict:\n            raise ValueError(f\"Unsupported basemap '{basemap_name}'.\")\n\n        tile_url = tile_dict[basemap_name]\n        attr = attr_dict.get(basemap_name, basemap_name)\n\n        tile_layer = folium.TileLayer(tiles=tile_url, attr=attr, name=basemap_name)\n        tile_layer.add_to(self.map)\n        self._layers.append(tile_layer)\n\n    def add_layer_control(self):\n        \"\"\"\n        Add a layer control widget to the map.\n\n        Returns:\n        -------\n        None\n        \"\"\"\n        folium.LayerControl().add_to(self.map)\n\n    def add_vector(self, data, layer_name=\"Vector Layer\"):\n        \"\"\"\n        Add vector data to the map. Accepts file paths or GeoDataFrames.\n\n        Parameters:\n        ----------\n        data : str or geopandas.GeoDataFrame\n            Path to the vector data file or a GeoDataFrame.\n        layer_name : str\n            Name of the layer to display.\n\n        Returns:\n        -------\n        None\n        \"\"\"\n        if isinstance(data, str):\n            if not os.path.exists(data):\n                raise FileNotFoundError(f\"File '{data}' not found.\")\n            gdf = gpd.read_file(data)\n        elif isinstance(data, gpd.GeoDataFrame):\n            gdf = data\n        else:\n            raise TypeError(\"Data must be a file path or a GeoDataFrame.\")\n\n        geojson = folium.GeoJson(gdf, name=layer_name)\n        geojson.add_to(self.map)\n        self._layers.append(geojson)\n\n    def display(self):\n        \"\"\"\n        Return the folium map object for display in Jupyter.\n\n        Returns:\n        -------\n        folium.Map\n        \"\"\"\n        return self.map\n</pre> class Map:     \"\"\"     A custom folium-based map class for the homestock package,     supporting basemaps, layer control, and vector data visualization.     \"\"\"      def __init__(self, location=(0, 0), zoom_start=2):         \"\"\"         Initialize the Map.          Parameters:         ----------         location : tuple             Center of the map in (lat, lon).         zoom_start : int             Initial zoom level.         \"\"\"         self.map = folium.Map(location=location, zoom_start=zoom_start)         self._layers = []      def add_basemap(self, basemap_name: str):         \"\"\"         Add a basemap to the map.          Parameters:         ----------         basemap_name : str             Name of the basemap. Supported values:             \"OpenStreetMap\", \"Esri.WorldImagery\", \"OpenTopoMap\".          Returns:         -------         None         \"\"\"         tile_dict = {             \"OpenStreetMap\": \"OpenStreetMap\",             \"Esri.WorldImagery\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\",             \"OpenTopoMap\": \"https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png\",         }          attr_dict = {             \"Esri.WorldImagery\": \"Tiles \u00a9 Esri \u2014 Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye\",             \"OpenTopoMap\": \"\u00a9 OpenTopoMap (CC-BY-SA)\",         }          if basemap_name not in tile_dict:             raise ValueError(f\"Unsupported basemap '{basemap_name}'.\")          tile_url = tile_dict[basemap_name]         attr = attr_dict.get(basemap_name, basemap_name)          tile_layer = folium.TileLayer(tiles=tile_url, attr=attr, name=basemap_name)         tile_layer.add_to(self.map)         self._layers.append(tile_layer)      def add_layer_control(self):         \"\"\"         Add a layer control widget to the map.          Returns:         -------         None         \"\"\"         folium.LayerControl().add_to(self.map)      def add_vector(self, data, layer_name=\"Vector Layer\"):         \"\"\"         Add vector data to the map. Accepts file paths or GeoDataFrames.          Parameters:         ----------         data : str or geopandas.GeoDataFrame             Path to the vector data file or a GeoDataFrame.         layer_name : str             Name of the layer to display.          Returns:         -------         None         \"\"\"         if isinstance(data, str):             if not os.path.exists(data):                 raise FileNotFoundError(f\"File '{data}' not found.\")             gdf = gpd.read_file(data)         elif isinstance(data, gpd.GeoDataFrame):             gdf = data         else:             raise TypeError(\"Data must be a file path or a GeoDataFrame.\")          geojson = folium.GeoJson(gdf, name=layer_name)         geojson.add_to(self.map)         self._layers.append(geojson)      def display(self):         \"\"\"         Return the folium map object for display in Jupyter.          Returns:         -------         folium.Map         \"\"\"         return self.map"},{"location":"usage/","title":"Usage","text":"<p>To use homestock in a project:</p> <pre><code>import homestock\n</code></pre>"},{"location":"examples/homestock_example/","title":"Homestock Example","text":"In\u00a0[1]: Copied! <pre>import sys, os\n\n# Assuming notebook lives in docs/examples/\nrepo_root = os.path.abspath(os.path.join(os.getcwd(), \"..\", \"..\"))\nsys.path.insert(0, repo_root)\n\nimport homestock\n</pre> import sys, os  # Assuming notebook lives in docs/examples/ repo_root = os.path.abspath(os.path.join(os.getcwd(), \"..\", \"..\")) sys.path.insert(0, repo_root)  import homestock In\u00a0[2]: Copied! <pre># Import the necessary modules from the homestock package\nimport homestock\nfrom homestock.homestock import Map\nimport ipyleaflet\nimport folium\nimport localtileserver\n\n# Create a Map instance from the homestock package\nm = Map(center=[40.7128, -74.0060], zoom=10)  # Center map on New York City\n\n# Add a basemap to the map\nm.add_basemap(\"Esri.WorldImagery\")\n\n# Display the map in the notebook\nm\n\n# Add a GeoJSON layer to the map (optional demonstration of GeoJSON)\ngeojson_data = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Point\",\n                \"coordinates\": [-74.0060, 40.7128],\n            },\n            \"properties\": {\n                \"name\": \"New York City\",\n            },\n        }\n    ],\n}\nm.add_geojson(geojson_data)\n\n# Set the center of the map to a new location (e.g., a different city)\nm.set_center(lat=34.0522, lon=-118.2437, zoom=10)  # Center map on Los Angeles\nm\n\n# Add a vector layer (GeoJSON or other supported format)\nvector_data = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                    [\n                        [-118.3, 34.0],\n                        [-118.2, 34.0],\n                        [-118.2, 34.1],\n                        [-118.3, 34.1],\n                        [-118.3, 34.0],\n                    ]\n                ],\n            },\n            \"properties\": {\"name\": \"Los Angeles Area\"},\n        }\n    ],\n}\nm.add_vector(vector_data)\n\n# Add a raster layer (demonstrating cloud-optimized GeoTIFF usage)\n# m.add_raster(filepath=\"path_to_your_raster_file.tif\")\n\n# Add a video overlay (use a video file URL)\n# m.add_video(url=\"https://example.com/your_video.mp4\", bounds=[[34.0, -118.4], [34.1, -118.2]])\n\n# Add a WMS layer\n# m.add_wms_layer(\n#     url=\"https://example.com/wms_service\",\n#     layers=\"your_layer_name\",\n#     name=\"Example WMS Layer\",\n#     format=\"image/png\",\n#     transparent=True,\n# )\n\n# Add basemap dropdown control to switch between basemaps\nm.add_basemap_dropdown()\n\n# Display the map\nm\n</pre> # Import the necessary modules from the homestock package import homestock from homestock.homestock import Map import ipyleaflet import folium import localtileserver  # Create a Map instance from the homestock package m = Map(center=[40.7128, -74.0060], zoom=10)  # Center map on New York City  # Add a basemap to the map m.add_basemap(\"Esri.WorldImagery\")  # Display the map in the notebook m  # Add a GeoJSON layer to the map (optional demonstration of GeoJSON) geojson_data = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"Point\",                 \"coordinates\": [-74.0060, 40.7128],             },             \"properties\": {                 \"name\": \"New York City\",             },         }     ], } m.add_geojson(geojson_data)  # Set the center of the map to a new location (e.g., a different city) m.set_center(lat=34.0522, lon=-118.2437, zoom=10)  # Center map on Los Angeles m  # Add a vector layer (GeoJSON or other supported format) vector_data = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"Polygon\",                 \"coordinates\": [                     [                         [-118.3, 34.0],                         [-118.2, 34.0],                         [-118.2, 34.1],                         [-118.3, 34.1],                         [-118.3, 34.0],                     ]                 ],             },             \"properties\": {\"name\": \"Los Angeles Area\"},         }     ], } m.add_vector(vector_data)  # Add a raster layer (demonstrating cloud-optimized GeoTIFF usage) # m.add_raster(filepath=\"path_to_your_raster_file.tif\")  # Add a video overlay (use a video file URL) # m.add_video(url=\"https://example.com/your_video.mp4\", bounds=[[34.0, -118.4], [34.1, -118.2]])  # Add a WMS layer # m.add_wms_layer( #     url=\"https://example.com/wms_service\", #     layers=\"your_layer_name\", #     name=\"Example WMS Layer\", #     format=\"image/png\", #     transparent=True, # )  # Add basemap dropdown control to switch between basemaps m.add_basemap_dropdown()  # Display the map m Out[2]:"}]}